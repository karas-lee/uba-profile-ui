<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UBA 프로파일 분석 결과</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #1e293b 0%, #334155 50%, #475569 100%);
            color: #e2e8f0;
            min-height: 100vh;
            font-size: 0.9rem;
            padding: 20px;
        }

        .dashboard-container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(30, 41, 59, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(51, 65, 85, 0.3);
            min-height: calc(100vh - 40px);
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            padding: 30px;
            border-bottom: 1px solid rgba(51, 65, 85, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-title h1 {
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.3rem;
        }

        .header-title p {
            color: #94a3b8;
            font-size: 0.95rem;
        }

        .header-actions {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .profile-header {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(51, 65, 85, 0.3);
            border-radius: 0.6rem;
            padding: 1.25rem;
            margin: 0 30px 1.5rem 30px;
            display: flex;
            justify-content: space-between;
        }

        .profile-info {
            flex: 1;
        }

        .profile-name {
            font-size: 1.6rem;
            font-weight: 600;
            margin-bottom: 0.4rem;
            color: #f1f5f9;
        }

        .profile-meta {
            display: flex;
            gap: 1.5rem;
            margin-top: 0.75rem;
        }

        .profile-meta-item {
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
        }

        .meta-label {
            font-size: 0.85rem;
            color: #94a3b8;
        }

        .meta-value {
            font-size: 1rem;
            color: #e2e8f0;
        }

        .profile-score {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: 135px;
        }

        .profile-nav {
            display: flex;
            gap: 0.75rem;
            margin: 0 30px 1.5rem 30px;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(51, 65, 85, 0.3);
        }

        .nav-item {
            padding: 0.6rem 1.25rem;
            font-size: 0.95rem;
            font-weight: 500;
            color: #94a3b8;
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 2px solid transparent;
            text-decoration: none;
        }

        .nav-item:hover {
            color: #e2e8f0;
        }

        .nav-item.active {
            color: #6366f1;
            border-bottom: 2px solid #6366f1;
        }

        .score-circle {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: conic-gradient(#6366f1 0%, #6366f1 70%, #1f2937 70%, #1f2937 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            margin-bottom: 0.4rem;
        }

        .score-circle::after {
            content: '';
            position: absolute;
            width: 85px;
            height: 85px;
            border-radius: 50%;
            background: #1a2332;
        }

        .score-value {
            position: relative;
            z-index: 1;
            font-size: 1.8rem;
            font-weight: 700;
            color: #f1f5f9;
        }

        .score-label {
            font-size: 0.85rem;
            color: #94a3b8;
            text-align: center;
        }

        .risk-level {
            font-size: 1rem;
            font-weight: 600;
            color: #a5b4fc;
            margin-top: 0.4rem;
        }

        .btn {
            padding: 0.6rem 1.25rem;
            border: none;
            border-radius: 0.4rem;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #5856eb, #7c3aed);
            transform: translateY(-1px);
            box-shadow: 0 8px 20px rgba(99, 102, 241, 0.3);
        }

        .btn-secondary {
            background: rgba(51, 65, 85, 0.7);
            color: #e2e8f0;
            border: 1px solid rgba(51, 65, 85, 0.5);
        }

        .btn-secondary:hover {
            background: rgba(51, 65, 85, 0.9);
            transform: translateY(-2px);
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
            margin: 0 30px 2rem 30px;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .dashboard-card {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(51, 65, 85, 0.3);
            border-radius: 0.75rem;
            padding: 1.5rem;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .card-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #f1f5f9;
        }

        .card-actions {
            display: flex;
            gap: 0.5rem;
        }

        .card-action {
            background: rgba(51, 65, 85, 0.5);
            border: none;
            border-radius: 0.375rem;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #94a3b8;
        }

        .card-action:hover {
            background: rgba(51, 65, 85, 0.8);
            color: #e2e8f0;
        }

        .chart-container {
            flex: 1;
            position: relative;
            min-height: 250px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .metric-item {
            background: rgba(15, 23, 42, 0.5);
            border-radius: 0.5rem;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .metric-info {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .metric-name {
            font-size: 0.9rem;
            color: #94a3b8;
        }

        .metric-value {
            font-size: 1.25rem;
            color: #f1f5f9;
            font-weight: 600;
        }

        .metric-indicator {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .indicator-normal {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .indicator-warning {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
        }

        .indicator-critical {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .table-container {
            overflow-x: auto;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
        }

        .data-table th,
        .data-table td {
            padding: 0.75rem 1rem;
            text-align: left;
            border-bottom: 1px solid rgba(51, 65, 85, 0.3);
        }

        .data-table th {
            font-weight: 600;
            color: #94a3b8;
            font-size: 0.9rem;
        }

        .data-table tbody tr {
            transition: background-color 0.2s;
        }

        .data-table tbody tr:hover {
            background: rgba(51, 65, 85, 0.2);
        }

        .severity-high {
            color: #ef4444;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .severity-medium {
            color: #f59e0b;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .severity-low {
            color: #10b981;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .severity-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .severity-high .severity-indicator {
            background-color: #ef4444;
        }

        .severity-medium .severity-indicator {
            background-color: #f59e0b;
        }

        .severity-low .severity-indicator {
            background-color: #10b981;
        }

        .recommendations {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .recommendation-item {
            background: rgba(15, 23, 42, 0.5);
            border-radius: 0.5rem;
            padding: 1.25rem;
            display: flex;
            align-items: flex-start;
            gap: 1rem;
        }

        .recommendation-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(99, 102, 241, 0.2);
            color: #a5b4fc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            flex-shrink: 0;
        }

        .recommendation-content {
            flex: 1;
        }

        .recommendation-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #f1f5f9;
            margin-bottom: 0.5rem;
        }

        .recommendation-text {
            color: #94a3b8;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .activity-timeline {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            padding-left: 1rem;
            position: relative;
        }

        .activity-timeline::before {
            content: '';
            position: absolute;
            left: 0;
            top: 10px;
            bottom: 10px;
            width: 2px;
            background: rgba(51, 65, 85, 0.5);
        }

        .timeline-item {
            position: relative;
            padding-left: 1.5rem;
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: -5px;
            top: 6px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #6366f1;
            border: 2px solid #1a2332;
        }

        .timeline-time {
            font-size: 0.8rem;
            color: #94a3b8;
            margin-bottom: 0.25rem;
        }

        .timeline-content {
            font-size: 0.9rem;
            color: #e2e8f0;
            line-height: 1.4;
        }

        .timeline-anomaly {
            background: rgba(239, 68, 68, 0.1);
            border-left: 3px solid rgba(239, 68, 68, 0.5);
            padding: 0.5rem;
            margin-top: 0.5rem;
            border-radius: 0 0.25rem 0.25rem 0;
        }

        .nav-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 2rem;
        }

        @media (max-width: 992px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .profile-header {
                flex-direction: column;
                gap: 1.5rem;
            }

            .profile-score {
                align-self: center;
            }

            .metrics-grid {
                grid-template-columns: 1fr;
            }
        }

        /* 차트 스타일 */
        .chart-placeholder {
            width: 100%;
            height: 250px;
            background: rgba(15, 23, 42, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.5rem;
            color: #94a3b8;
            font-size: 0.9rem;
        }

        /* 베이스라인 메트릭 비교 스타일 */
        .baseline-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 1rem;
        }

        .baseline-metric-item {
            background: rgba(15, 23, 42, 0.5);
            border-radius: 0.5rem;
            padding: 1rem;
        }

        .baseline-metric-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .baseline-metric-name {
            font-size: 0.95rem;
            color: #94a3b8;
        }

        .baseline-deviation {
            font-size: 0.9rem;
            font-weight: 600;
            padding: 0.15rem 0.5rem;
            border-radius: 9999px;
        }

        .baseline-deviation.low {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .baseline-deviation.medium {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
        }

        .baseline-deviation.high {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .baseline-comparison-bar {
            height: 30px;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 4px;
            position: relative;
            margin-top: 0.5rem;
        }

        .baseline-normal-range {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(74, 222, 128, 0.2);
            border: 1px solid rgba(74, 222, 128, 0.3);
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 0.5rem;
        }

        .baseline-min, .baseline-max {
            font-size: 0.75rem;
            color: #4ade80;
        }

        .baseline-current-value {
            position: absolute;
            top: -20px;
            transform: translateX(-50%);
            background: rgba(99, 102, 241, 0.2);
            border: 1px solid rgba(99, 102, 241, 0.3);
            color: #818cf8;
            padding: 0.15rem 0.5rem;
            border-radius: 9999px;
            font-size: 0.8rem;
            white-space: nowrap;
        }

        .baseline-current-value::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 5px solid rgba(99, 102, 241, 0.3);
        }

        .heatmap-container {
            height: 200px;
            background: rgba(15, 23, 42, 0.3);
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (max-width: 992px) {
            .baseline-metrics {
                grid-template-columns: 1fr;
            }
        }

        .normal-range-info {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-left: 4px solid #28a745;
            padding: 12px;
            margin: 8px 0;
            border-radius: 6px;
            font-size: 0.9em;
            line-height: 1.5;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .normal-range-info strong {
            color: #155724;
            display: block;
            margin-bottom: 8px;
            font-size: 1em;
        }

        .normal-range-info br {
            line-height: 1.8;
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <div class="header">
            <div class="header-title">
                <h1>UBA 프로파일 분석 결과</h1>
                <p>사용자 행동 분석 결과 및 이상 징후를 확인하세요</p>
            </div>
            <div class="header-actions">
                <a href="uba_individual_users.html" class="btn btn-secondary" style="text-decoration: none;">👥 개별 사용자 분석</a>
                <button class="btn btn-secondary" onclick="goBackToList()">
                    ← 목록으로 돌아가기
                </button>
            </div>
        </div>

        <div class="profile-header">
            <div class="profile-info">
                <h2 class="profile-name" id="profileName">UBA 프로파일 이름</h2>
                <div class="profile-meta">
                    <div class="profile-meta-item">
                        <div class="meta-label">프로파일 유형</div>
                        <div class="meta-value" id="profileType">사용자 프로파일</div>
                    </div>
                    <div class="profile-meta-item">
                        <div class="meta-label">로그 소스</div>
                        <div class="meta-value" id="logSource">Windows 이벤트 로그</div>
                    </div>
                    <div class="profile-meta-item">
                        <div class="meta-label">분석 기간</div>
                        <div class="meta-value" id="analysisPeriod">2025-05-01 ~ 2025-06-01</div>
                    </div>
                    <div class="profile-meta-item">
                        <div class="meta-label">생성일</div>
                        <div class="meta-value" id="creationDate">2025-04-15</div>
                    </div>
                </div>
            </div>
            <div class="profile-score">
                <div class="score-circle">
                    <div class="score-value" id="riskScore">70</div>
                </div>
                <div class="score-label">위험 점수</div>
                <div class="risk-level" id="riskLevel">중간 위험</div>
            </div>
        </div>

                  <div class="profile-nav">
              <a href="uba_profile_results.html" class="nav-item active">프로파일 분석</a>
              <a href="uba_individual_users.html" class="nav-item">개별 사용자 분석</a>
              <a href="#" class="nav-item" onclick="goToBaselineManagement()">베이스라인 관리</a>
          </div>

        <div class="dashboard-grid">








            <!-- 메트릭 분석 결과 -->
            <div class="dashboard-card full-width">
                <div class="card-header">
                    <h3 class="card-title">메트릭 분석</h3>
                    <div class="card-actions">
                        <button class="card-action" title="베이스라인 비교 표시" onclick="toggleBaselineComparison(true)">B</button>
                        <button class="card-action" title="현재 행동만 표시" onclick="toggleBaselineComparison(false)">C</button>
                    </div>
                </div>

                <!-- 3가지 분석 차트 영역 -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 1.5rem; margin-top: 1rem;">

                    <!-- 시간 기반 분석 -->
                    <div style="background: linear-gradient(135deg, rgba(15, 23, 42, 0.6) 0%, rgba(30, 41, 59, 0.4) 100%); border-radius: 1rem; padding: 1.5rem; border: 1px solid rgba(148, 163, 184, 0.2);">
                        <div style="display: flex; align-items: center; margin-bottom: 1rem;">
                            <span style="font-size: 1.5rem; margin-right: 0.5rem;">⏰</span>
                            <h4 style="color: #f1f5f9; font-size: 1.1rem; margin: 0;">시간 기반 분석</h4>
                        </div>
                        <div class="chart-container" id="timeBasedChart" style="height: 250px;">
                            <div class="chart-placeholder">시간 패턴 차트를 로드하는 중...</div>
                        </div>
                        <div id="timeBasedMetricsList" style="margin-top: 0.5rem; font-size: 0.85rem; color: #94a3b8;">
                            로그인 시간, 세션 지속시간, 업무시간 외 활동 등
                        </div>
                    </div>

                    <!-- 네트워크 기반 분석 -->
                    <div style="background: linear-gradient(135deg, rgba(15, 23, 42, 0.6) 0%, rgba(30, 41, 59, 0.4) 100%); border-radius: 1rem; padding: 1.5rem; border: 1px solid rgba(148, 163, 184, 0.2);">
                        <div style="display: flex; align-items: center; margin-bottom: 1rem;">
                            <span style="font-size: 1.5rem; margin-right: 0.5rem;">🌐</span>
                            <h4 style="color: #f1f5f9; font-size: 1.1rem; margin: 0;">네트워크 기반 분석</h4>
                        </div>
                        <div class="chart-container" id="networkBasedChart" style="height: 250px;">
                            <div class="chart-placeholder">네트워크 패턴 차트를 로드하는 중...</div>
                        </div>
                        <div id="networkBasedMetricsList" style="margin-top: 0.5rem; font-size: 0.85rem; color: #94a3b8;">
                            IP 주소, 지리적 위치, 데이터 전송량, VPN 사용 등
                        </div>
                    </div>

                    <!-- 접근 기반 분석 -->
                    <div style="background: linear-gradient(135deg, rgba(15, 23, 42, 0.6) 0%, rgba(30, 41, 59, 0.4) 100%); border-radius: 1rem; padding: 1.5rem; border: 1px solid rgba(148, 163, 184, 0.2);">
                        <div style="display: flex; align-items: center; margin-bottom: 1rem;">
                            <span style="font-size: 1.5rem; margin-right: 0.5rem;">🔐</span>
                            <h4 style="color: #f1f5f9; font-size: 1.1rem; margin: 0;">접근 기반 분석</h4>
                        </div>
                        <div class="chart-container" id="accessBasedChart" style="height: 250px;">
                            <div class="chart-placeholder">접근 패턴 차트를 로드하는 중...</div>
                        </div>
                        <div id="accessBasedMetricsList" style="margin-top: 0.5rem; font-size: 0.85rem; color: #94a3b8;">
                            로그인 빈도, 동시 세션, 디바이스 변경, 대역폭 사용 등
                        </div>
                    </div>
                </div>

                <!-- 범례 -->
                <div class="baseline-legend" style="display: flex; justify-content: center; margin-top: 1.5rem; gap: 20px; font-size: 0.9rem;">
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <div style="width: 12px; height: 12px; background: #22c55e; border-radius: 50%;"></div>
                        <span>품질 점수 80% 이상</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <div style="width: 12px; height: 12px; background: #eab308; border-radius: 50%;"></div>
                        <span>품질 점수 60-80%</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <div style="width: 12px; height: 12px; background: #ef4444; border-radius: 50%;"></div>
                        <span>품질 점수 60% 미만</span>
                    </div>
                </div>
            </div>

            <!-- 조치 권장사항 -->
            <div class="dashboard-card">
                <div class="card-header">
                    <h3 class="card-title">조치 권장사항</h3>
                </div>
                <div class="recommendations">
                    <div class="recommendation-item">
                        <div class="recommendation-icon">🔒</div>
                        <div class="recommendation-content">
                            <div class="recommendation-title">계정 보안 강화</div>
                            <div class="recommendation-text">2단계 인증(MFA)을 활성화하고 정기적인 비밀번호 변경을 요청하세요.</div>
                        </div>
                    </div>
                    <div class="recommendation-item">
                        <div class="recommendation-icon">🌐</div>
                        <div class="recommendation-content">
                            <div class="recommendation-title">IP 제한 설정</div>
                            <div class="recommendation-text">허용된 IP 주소 또는 지역에서만 접속을 허용하도록 설정하세요.</div>
                        </div>
                    </div>
                    <div class="recommendation-item">
                        <div class="recommendation-icon">⏰</div>
                        <div class="recommendation-content">
                            <div class="recommendation-title">업무시간 접속 제한</div>
                            <div class="recommendation-text">업무시간 외 접속 시 추가 인증을 요구하는 정책을 적용하세요.</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 조치 권장사항 카드 앞에 새로운 베이스라인 정보 카드 추가 -->
            <div class="dashboard-card full-width">
                <div class="card-header">
                    <h3 class="card-title">학습된 베이스라인 정보</h3>
                    <div class="card-actions">
                        <button class="card-action" title="베이스라인 상세 정보" onclick="showBaselineDetails()">ℹ️</button>
                    </div>
                </div>

                <div style="padding: 0 0 1rem 0;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 1rem; background: rgba(15, 23, 42, 0.3); padding: 1rem; border-radius: 0.5rem;">
                        <div>
                            <div style="font-size: 0.9rem; color: #94a3b8; margin-bottom: 0.25rem;">학습 기간</div>
                            <div style="font-size: 1.1rem; color: #f1f5f9;"><span id="learningDays">30</span>일</div>
                        </div>
                        <div>
                            <div style="font-size: 0.9rem; color: #94a3b8; margin-bottom: 0.25rem;">처리된 데이터</div>
                            <div style="font-size: 1.1rem; color: #f1f5f9;"><span id="processedEvents">14,589</span>개 이벤트</div>
                        </div>
                        <div>
                            <div style="font-size: 0.9rem; color: #94a3b8; margin-bottom: 0.25rem;">마지막 업데이트</div>
                            <div style="font-size: 1.1rem; color: #f1f5f9;"><span id="lastUpdated">2025-06-01 06:00</span></div>
                        </div>
                        <div>
                            <div style="font-size: 0.9rem; color: #94a3b8; margin-bottom: 0.25rem;">베이스라인 품질</div>
                            <div style="font-size: 1.1rem; color: #4ade80;">양호</div>
                        </div>
                    </div>



                    <h4 style="margin: 1.5rem 0 1rem 0; font-size: 1.1rem; color: #f1f5f9;">시간대별 활동 패턴</h4>
                    <div class="heatmap-container">
                        <div class="chart-placeholder">시간대별 활동 히트맵을 로드하는 중...</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="nav-buttons">
            <button class="btn btn-secondary" onclick="goBackToList()">목록으로 돌아가기</button>
            <button class="btn btn-primary" onclick="exportReport()">분석 결과 다운로드</button>
            <button class="btn btn-info" onclick="showDeviationScoreCalculator()">편차 점수 계산</button>
        </div>
    </div>

    <script>
        let profileData = null;

        // URL에서 프로파일 ID 추출 함수
        function getProfileIdFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('id');
        }

        // 페이지 로드 시 실행
        document.addEventListener('DOMContentLoaded', () => {
            // URL에서 프로필 ID 가져오기
            const urlParams = new URLSearchParams(window.location.search);
            const profileId = urlParams.get('id');

            if (profileId) {
                loadProfileResults(profileId);

                // 네비게이션 탭의 href 속성 업데이트
                const navLinks = document.querySelectorAll('.profile-nav a');
                navLinks.forEach(link => {
                    const href = link.getAttribute('href');
                    link.setAttribute('href', `${href}?id=${profileId}`);
                });
            } else {
                alert('프로필 정보를 찾을 수 없습니다.');
                goBackToList();
            }

            // 차트 초기화 (실제로는 Chart.js 등의 라이브러리를 사용할 것)
            simulateChartLoading();
        });

        // 프로필 결과 로드
        async function loadProfileResults(profileId) {
            try {
                console.log('프로파일 결과 로딩 시작:', profileId);

                // 로딩 상태 표시
                showLoadingState();

                // 베이스라인 엔진에서 프로파일 정보 조회
                const profileResponse = await fetch(`/api/profiles/${profileId}`);
                if (!profileResponse.ok) {
                    throw new Error(`프로파일 조회 실패: ${profileResponse.status}`);
                }

                profileData = await profileResponse.json();
                console.log('프로파일 데이터:', profileData);

                // 베이스라인 상태 조회
                let baselineStatus = null;
                try {
                    const statusResponse = await fetch(`/api/profiles/${profileId}/baseline/status`);
                    if (statusResponse.ok) {
                        baselineStatus = await statusResponse.json();
                        console.log('베이스라인 상태:', baselineStatus);
                    }
                } catch (error) {
                    console.warn('베이스라인 상태 조회 실패:', error.message);
                }

                // 베이스라인 분석 결과 조회
                let baselineResults = null;
                try {
                    const resultsResponse = await fetch(`/api/profiles/${profileId}/baseline/results`);
                    if (resultsResponse.ok) {
                        baselineResults = await resultsResponse.json();
                        console.log('베이스라인 분석 결과:', baselineResults);

                        // 전역 변수에 베이스라인 결과 저장
                        window.currentBaselineResults = baselineResults;
                    }
                } catch (error) {
                    console.warn('베이스라인 분석 결과 조회 실패:', error.message);
                }

                // 프로파일 정보 표시
                displayProfileInfo(profileData, baselineStatus, baselineResults);

                // 베이스라인 정보 업데이트
                updateBaselineInfo(baselineStatus);

                // 실제 분석 결과로 차트 업데이트
                await updateAnalysisCharts(baselineResults);

                // 로딩 상태 해제
                hideLoadingState();

                console.log('프로파일 결과 로딩 완료');

            } catch (error) {
                console.error('프로파일 결과 로딩 실패:', error);
                showErrorState(error.message);
            }
        }

        // 로딩 상태 표시
        function showLoadingState() {
            const container = document.querySelector('.dashboard-container');
            const loadingHtml = `
                <div id="loadingOverlay" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(15, 20, 25, 0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 9999;
                ">
                    <div style="text-align: center; color: #e2e8f0;">
                        <div style="width: 50px; height: 50px; border: 3px solid #334155; border-top: 3px solid #6366f1; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 1rem;"></div>
                        <p>프로파일 데이터를 불러오는 중...</p>
                    </div>
                </div>
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
            `;
            document.body.insertAdjacentHTML('beforeend', loadingHtml);
        }

        // 로딩 상태 해제
        function hideLoadingState() {
            const loadingOverlay = document.getElementById('loadingOverlay');
            if (loadingOverlay) {
                loadingOverlay.remove();
            }
        }

        // 오류 상태 표시
        function showErrorState(errorMessage) {
            hideLoadingState();
            const container = document.querySelector('.dashboard-container');
            container.innerHTML = `
                <div style="
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    min-height: 60vh;
                    text-align: center;
                    color: #e2e8f0;
                ">
                    <div style="font-size: 4rem; margin-bottom: 1rem;">⚠️</div>
                    <h2 style="margin-bottom: 1rem; color: #ef4444;">프로파일을 불러올 수 없습니다</h2>
                    <p style="margin-bottom: 2rem; color: #94a3b8;">${errorMessage}</p>
                    <div style="display: flex; gap: 1rem;">
                        <button class="btn btn-primary" onclick="location.reload()">다시 시도</button>
                        <button class="btn btn-secondary" onclick="goBackToList()">목록으로 돌아가기</button>
                    </div>
                </div>
            `;
        }

        // 프로필 기본 정보 표시
        function displayProfileInfo(profile, baselineStatus, baselineResults) {
            document.getElementById('profileName').textContent = profile.name;

            // 프로파일 유형 (베이스라인 엔진 API 구조 기준)
            let profileTypeText;
            switch (profile.profile_type) {
                case 'user': profileTypeText = '사용자'; break;
                case 'hybrid': profileTypeText = '하이브리드'; break;
                case 'group': profileTypeText = '그룹'; break;
                default: profileTypeText = '사용자 정의';
            }
            document.getElementById('profileType').textContent = profileTypeText + ' 프로파일';

            // 로그 소스 (베이스라인 엔진 API 구조 기준)
            const logSourceMap = {
                'vpn': 'VPN',
                'proxy': '프록시',
                'database': '데이터베이스',
                'application': '애플리케이션',
                'system': '시스템'
            };
            document.getElementById('logSource').textContent = logSourceMap[profile.log_source] || profile.log_source;

            // 분석 기간 (학습 기간 기준으로 계산)
            const today = new Date();
            const startDate = new Date();
            startDate.setDate(today.getDate() - (profile.learning_period || 30));

            const formatDate = (date) => {
                return date.toLocaleDateString('ko-KR', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit'
                }).replace(/\. /g, '-').replace('.', '');
            };

            document.getElementById('analysisPeriod').textContent =
                `${formatDate(startDate)} ~ ${formatDate(today)}`;

            // 생성일 (베이스라인 엔진 API 구조 기준)
            if (profile.created_at) {
                const createdDate = new Date(profile.created_at);
                document.getElementById('creationDate').textContent = formatDate(createdDate);
            } else {
                document.getElementById('creationDate').textContent = '-';
            }

            // 실제 베이스라인 분석 결과 기반 위험 점수 계산
            let riskScore = calculateRiskScore(baselineStatus, baselineResults);

            // 점수가 0인 경우 (API 미구현 등) 표시하지 않음
            if (riskScore === 0) {
                document.getElementById('riskScore').textContent = '-';
                document.getElementById('riskLevel').textContent = '데이터 없음';
                document.getElementById('riskLevel').style.color = '#94a3b8';
                document.querySelector('.score-circle').style.background = 'conic-gradient(#475569 0%, #475569 100%)';
            } else {
                document.getElementById('riskScore').textContent = riskScore;

                // 위험 수준 설정
                let riskLevel;
                let scoreGradient;
                if (riskScore >= 75) {
                    riskLevel = '높은 위험';
                    scoreGradient = `conic-gradient(#ef4444 0%, #ef4444 ${riskScore}%, #1f2937 ${riskScore}%, #1f2937 100%)`;
                    document.getElementById('riskLevel').style.color = '#ef4444';
                } else if (riskScore >= 50) {
                    riskLevel = '중간 위험';
                    scoreGradient = `conic-gradient(#f59e0b 0%, #f59e0b ${riskScore}%, #1f2937 ${riskScore}%, #1f2937 100%)`;
                    document.getElementById('riskLevel').style.color = '#f59e0b';
                } else {
                    riskLevel = '낮은 위험';
                    scoreGradient = `conic-gradient(#10b981 0%, #10b981 ${riskScore}%, #1f2937 ${riskScore}%, #1f2937 100%)`;
                    document.getElementById('riskLevel').style.color = '#10b981';
                }

                document.getElementById('riskLevel').textContent = riskLevel;
                document.querySelector('.score-circle').style.background = scoreGradient;
            }
        }



        // 목록으로 돌아가기
        function goBackToList() {
            window.location.href = 'uba_integrated_management.html';
        }

        // 베이스라인 관리 페이지로 이동
        function goToBaselineManagement() {
            const urlParams = new URLSearchParams(window.location.search);
            const profileId = urlParams.get('id');

            if (profileId) {
                window.location.href = `uba_baseline_management.html?id=${profileId}`;
            } else {
                alert('프로파일 ID를 찾을 수 없습니다.');
            }
        }

        // 보고서 내보내기
        function exportReport() {
            alert('분석 결과가 PDF 형식으로 다운로드됩니다. (구현 예정)');
            // 실제 구현에서는 PDF나 Excel로 내보내기
        }

        // 편차 점수 계산기 표시
        function showDeviationScoreCalculator() {
            const modal = document.createElement('div');
            modal.id = 'deviationModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;

            modal.innerHTML = `
                <div style="
                    background: #1e293b;
                    border-radius: 0.75rem;
                    padding: 2rem;
                    max-width: 500px;
                    width: 90%;
                    max-height: 80vh;
                    overflow-y: auto;
                    border: 1px solid #334155;
                ">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                        <h3 style="color: #e2e8f0; margin: 0;">편차 점수 계산</h3>
                        <button onclick="closeDeviationModal()" style="
                            background: none;
                            border: none;
                            color: #94a3b8;
                            font-size: 1.5rem;
                            cursor: pointer;
                            padding: 0;
                            width: 30px;
                            height: 30px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        ">×</button>
                    </div>

                    <form onsubmit="calculateDeviation(event)">
                        <div style="margin-bottom: 1rem;">
                            <label style="display: block; color: #e2e8f0; margin-bottom: 0.5rem; font-weight: 600;">
                                대상 엔터티 (사용자 ID) *
                            </label>
                            <input
                                type="text"
                                id="targetEntity"
                                placeholder="예: user001, john.doe@company.com"
                                required
                                style="
                                    width: 100%;
                                    padding: 0.75rem;
                                    background: #334155;
                                    border: 1px solid #475569;
                                    border-radius: 0.5rem;
                                    color: #e2e8f0;
                                    font-size: 0.9rem;
                                "
                            />
                            <div style="color: #94a3b8; font-size: 0.8rem; margin-top: 0.25rem;">
                                분석할 사용자의 식별자를 입력하세요
                            </div>
                        </div>

                        <div style="margin-bottom: 1rem;">
                            <label style="display: block; color: #e2e8f0; margin-bottom: 0.5rem; font-weight: 600;">
                                계산 기준일
                            </label>
                            <input
                                type="date"
                                id="calculationDate"
                                value="${new Date().toISOString().split('T')[0]}"
                                style="
                                    width: 100%;
                                    padding: 0.75rem;
                                    background: #334155;
                                    border: 1px solid #475569;
                                    border-radius: 0.5rem;
                                    color: #e2e8f0;
                                    font-size: 0.9rem;
                                "
                            />
                        </div>

                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; color: #e2e8f0; margin-bottom: 0.5rem; font-weight: 600;">
                                분석할 메트릭 (선택사항)
                            </label>
                            <div id="metricCheckboxes" style="
                                max-height: 150px;
                                overflow-y: auto;
                                padding: 0.5rem;
                                background: #334155;
                                border: 1px solid #475569;
                                border-radius: 0.5rem;
                            ">
                                <!-- 메트릭 체크박스들이 여기에 동적으로 생성됩니다 -->
                            </div>
                            <div style="color: #94a3b8; font-size: 0.8rem; margin-top: 0.25rem;">
                                선택하지 않으면 모든 메트릭을 분석합니다
                            </div>
                        </div>

                        <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                            <button type="button" onclick="closeDeviationModal()" style="
                                padding: 0.75rem 1.5rem;
                                background: #475569;
                                color: #e2e8f0;
                                border: none;
                                border-radius: 0.5rem;
                                cursor: pointer;
                                font-size: 0.9rem;
                            ">취소</button>
                            <button type="submit" style="
                                padding: 0.75rem 1.5rem;
                                background: #6366f1;
                                color: white;
                                border: none;
                                border-radius: 0.5rem;
                                cursor: pointer;
                                font-size: 0.9rem;
                            ">계산하기</button>
                        </div>
                    </form>

                    <div id="deviationResults" style="margin-top: 1.5rem; display: none;">
                        <!-- 계산 결과가 여기에 표시됩니다 -->
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // 메트릭 체크박스 생성
            generateMetricCheckboxes();
        }

        // 메트릭 체크박스 생성
        function generateMetricCheckboxes() {
            const container = document.getElementById('metricCheckboxes');
            if (!container || !profileData || !profileData.selected_metrics) return;

            const metricNameMap = {
                'login_time_pattern': '로그인 시간 패턴',
                'session_duration': '세션 지속 시간',
                'after_hours_activity': '업무시간 외 활동',
                'weekend_holiday_access': '주말/휴일 접근',
                'login_frequency_change': '로그인 빈도 변화',
                'concurrent_session_detection': '동시 세션 탐지',
                'timezone_anomaly_access': '시간대 이상 접근',
                'ip_address_pattern': 'IP 주소 패턴',
                'geo_location_analysis': '지리적 위치 분석',
                'data_volume_transfer': '데이터 전송량',
                'impossible_travel_detection': '불가능한 이동 탐지',
                'vpn_usage_pattern': 'VPN 사용 패턴',
                'network_device_change': '네트워크 디바이스 변경',
                'bandwidth_usage_anomaly': '대역폭 사용량 이상',
                'connection_pattern_analysis': '연결 패턴 분석',
                'proxy_bypass_attempt': '프록시 우회 시도',
                'resource_access_pattern': '리소스 접근 패턴',
                'file_download_pattern': '파일 다운로드 패턴',
                'application_usage_pattern': '애플리케이션 사용 패턴',
                'shared_folder_access': '공유 폴더 접근'
            };

            container.innerHTML = profileData.selected_metrics.map(metric => {
                const displayName = metricNameMap[metric] || metric;
                return `
                    <div style="margin-bottom: 0.5rem;">
                        <label style="display: flex; align-items: center; cursor: pointer; color: #e2e8f0;">
                            <input
                                type="checkbox"
                                name="selectedMetrics"
                                value="${metric}"
                                style="margin-right: 0.5rem;"
                            />
                            ${displayName}
                        </label>
                    </div>
                `;
            }).join('');
        }

        // 편차 점수 계산 실행
        async function calculateDeviation(event) {
            event.preventDefault();

            const targetEntity = document.getElementById('targetEntity').value.trim();
            const calculationDate = document.getElementById('calculationDate').value;
            const resultsContainer = document.getElementById('deviationResults');

            if (!targetEntity) {
                alert('대상 엔터티를 입력해주세요.');
                return;
            }

            // 선택된 메트릭 수집
            const selectedMetrics = Array.from(document.querySelectorAll('input[name="selectedMetrics"]:checked'))
                .map(cb => cb.value);

            // 로딩 상태 표시
            resultsContainer.style.display = 'block';
            resultsContainer.innerHTML = `
                <div style="text-align: center; padding: 2rem; color: #e2e8f0;">
                    <div style="width: 40px; height: 40px; border: 3px solid #334155; border-top: 3px solid #6366f1; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 1rem;"></div>
                    <p>편차 점수를 계산하는 중...</p>
                </div>
            `;

            try {
                const urlParams = new URLSearchParams(window.location.search);
                const profileId = urlParams.get('id');

                const requestData = {
                    target_entity: targetEntity,
                    calculation_date: calculationDate,
                    metric_names: selectedMetrics.length > 0 ? selectedMetrics : null
                };

                const response = await fetch(`/api/profiles/${profileId}/baseline/deviation`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || '편차 점수 계산 실패');
                }

                const result = await response.json();
                displayDeviationResults(result);

            } catch (error) {
                console.error('편차 점수 계산 오류:', error);
                resultsContainer.innerHTML = `
                    <div style="
                        background: rgba(239, 68, 68, 0.1);
                        border: 1px solid rgba(239, 68, 68, 0.3);
                        border-radius: 0.5rem;
                        padding: 1rem;
                        color: #ef4444;
                        text-align: center;
                    ">
                        <h4 style="margin: 0 0 0.5rem 0;">계산 실패</h4>
                        <p style="margin: 0; font-size: 0.9rem;">${error.message}</p>
                        <p style="margin: 0.5rem 0 0 0; font-size: 0.8rem; color: #fca5a5;">
                            베이스라인 엔진이 실행 중인지, 대상 엔터티가 올바른지 확인해주세요.
                        </p>
                    </div>
                `;
            }
        }

        // 편차 점수 결과 표시
        function displayDeviationResults(result) {
            const resultsContainer = document.getElementById('deviationResults');
            const deviationScores = result.deviation_scores;

            if (!deviationScores || (Array.isArray(deviationScores) && deviationScores.length === 0)) {
                resultsContainer.innerHTML = `
                    <div style="
                        background: rgba(245, 158, 11, 0.1);
                        border: 1px solid rgba(245, 158, 11, 0.3);
                        border-radius: 0.5rem;
                        padding: 1rem;
                        color: #f59e0b;
                        text-align: center;
                    ">
                        <h4 style="margin: 0 0 0.5rem 0;">데이터 없음</h4>
                        <p style="margin: 0; font-size: 0.9rem;">
                            해당 엔터티에 대한 편차 점수 데이터가 없습니다.
                        </p>
                    </div>
                `;
                return;
            }

            const scores = Array.isArray(deviationScores) ? deviationScores : [deviationScores];
            const avgScore = scores.reduce((sum, score) => sum + (score.deviation_score || 0), 0) / scores.length;

            resultsContainer.innerHTML = `
                <div style="
                    background: rgba(16, 185, 129, 0.1);
                    border: 1px solid rgba(16, 185, 129, 0.3);
                    border-radius: 0.5rem;
                    padding: 1rem;
                ">
                    <h4 style="color: #10b981; margin: 0 0 1rem 0;">📊 편차 점수 계산 결과</h4>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                        <div style="text-align: center;">
                            <div style="color: #94a3b8; font-size: 0.8rem;">대상 엔터티</div>
                            <div style="color: #e2e8f0; font-weight: 600;">${result.target_entity}</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #94a3b8; font-size: 0.8rem;">평균 편차 점수</div>
                            <div style="color: ${avgScore > 0.7 ? '#ef4444' : avgScore > 0.5 ? '#f59e0b' : '#10b981'}; font-weight: 600; font-size: 1.2rem;">
                                ${(avgScore * 100).toFixed(1)}%
                            </div>
                        </div>
                    </div>

                    <div style="color: #94a3b8; font-size: 0.8rem; margin-bottom: 0.5rem;">메트릭별 편차 점수:</div>
                    <div style="max-height: 200px; overflow-y: auto;">
                        ${scores.map(score => {
                            const percentage = (score.deviation_score * 100).toFixed(1);
                            const color = score.deviation_score > 0.7 ? '#ef4444' :
                                         score.deviation_score > 0.5 ? '#f59e0b' : '#10b981';
                            return `
                                <div style="
                                    display: flex;
                                    justify-content: space-between;
                                    align-items: center;
                                    padding: 0.5rem;
                                    background: rgba(30, 41, 59, 0.5);
                                    margin-bottom: 0.25rem;
                                    border-radius: 0.25rem;
                                ">
                                    <span style="color: #e2e8f0; font-size: 0.9rem;">
                                        ${score.metric_name || '알 수 없음'}
                                    </span>
                                    <span style="color: ${color}; font-weight: 600;">
                                        ${percentage}%
                                    </span>
                                </div>
                            `;
                        }).join('')}
                    </div>

                    <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(51, 65, 85, 0.5);">
                        <div style="color: #94a3b8; font-size: 0.8rem;">
                            📈 <strong>해석:</strong><br/>
                            • 0-30%: 정상 범위<br/>
                            • 30-70%: 주의 필요<br/>
                            • 70% 이상: 이상 행동 가능성
                        </div>
                    </div>
                </div>
            `;
        }

        // 편차 점수 계산기 모달 닫기
        function closeDeviationModal() {
            const modal = document.getElementById('deviationModal');
            if (modal) {
                modal.remove();
            }
        }

        // 차트 로딩 시뮬레이션 (실제 구현에서는 Chart.js 등의 라이브러리 사용)
        function simulateChartLoading() {
            // 실제 구현에서는 이 부분에 차트 라이브러리 코드가 들어갑니다.
            const placeholders = document.querySelectorAll('.chart-placeholder');

            placeholders.forEach((placeholder, index) => {
                setTimeout(() => {
                    placeholder.innerHTML = '차트 데이터 표시됨';
                    placeholder.style.background = 'rgba(51, 65, 85, 0.3)';
                }, 1000 + index * 500);
            });
        }

        // 베이스라인 상세 정보 보기
        function showBaselineDetails() {
            alert('베이스라인 학습 세부 정보\n\n' +
                  '- 데이터 소스: ' + profileData.logSourceName + '\n' +
                  '- 학습 시작일: 2025-05-01\n' +
                  '- 학습 종료일: 2025-06-01\n' +
                  '- 이상 행동 임계값: ' + profileData.anomalyThreshold + '\n' +
                  '- 처리된 총 이벤트 수: 14,589개\n' +
                  '- 평균 일일 이벤트: 486개\n' +
                  '- 정상 행동 판단 신뢰도: 85%');
        }

        // 베이스라인 비교 토글
        function toggleBaselineComparison(showBaseline) {
            const behaviorChart = document.getElementById('behaviorPatternChart');
            const placeholder = behaviorChart.querySelector('.chart-placeholder');

            if (showBaseline) {
                placeholder.textContent = '베이스라인과 현재 행동을 비교하는 레이더 차트';
                placeholder.style.background = 'rgba(51, 65, 85, 0.3)';
            } else {
                placeholder.textContent = '현재 행동 패턴만 표시하는 레이더 차트';
                placeholder.style.background = 'rgba(30, 41, 59, 0.5)';
            }
        }

        // 베이스라인 정보 데이터 채우기
        function updateBaselineInfo(baselineStatus) {
            if (profileData) {
                document.getElementById('learningDays').textContent = profileData.learning_period || '30';

                // 마지막 업데이트 시간
                let lastUpdatedText = '없음';
                if (baselineStatus && baselineStatus.latest_job) {
                    const lastUpdated = new Date(baselineStatus.latest_job.completed_at || baselineStatus.latest_job.created_at);
                    lastUpdatedText = lastUpdated.toLocaleDateString('ko-KR', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit'
                    }).replace(/\. /g, '-').replace('\.', '');
                } else {
                    lastUpdatedText = new Date().toLocaleDateString('ko-KR', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit'
                    }).replace(/\. /g, '-').replace('\.', '');
                }

                document.getElementById('lastUpdated').textContent = lastUpdatedText;

                // 베이스라인 메트릭 화면 제거됨
            }
        }

        // generateBaselineMetrics 함수 및 관련 함수들 제거됨

        // 실제 베이스라인 결과 기반 위험 점수 계산
        function calculateRiskScore(baselineStatus, baselineResults) {
            // 베이스라인 데이터가 없는 경우 - 상황에 따라 다르게 처리
            if (!baselineResults || !baselineResults.summary) {
                if (baselineResults && baselineResults.source === 'api_not_implemented') {
                    return 0; // API 미구현시 점수 표시 안함
                } else if (baselineResults && baselineResults.source === 'baseline_engine_error') {
                    return 0; // 엔진 오류시 점수 표시 안함
                } else {
                    return 75; // 데이터 없음 - 높은 위험
                }
            }

            let riskScore = 50; // 기본값
            const summary = baselineResults.summary;

            // 베이스라인 수와 이상치 수를 기반으로 점수 계산
            if (summary.total_baselines > 0) {
                // 기본적으로 낮은 위험 (베이스라인 존재)
                riskScore = 30;

                // 이상치가 많은 경우 위험 점수 증가
                if (summary.anomaly_count > 0) {
                    const anomalyRatio = summary.anomaly_count / summary.total_baselines;
                    if (anomalyRatio > 0.7) {
                        riskScore = 80; // 매우 높은 이상치 비율
                    } else if (anomalyRatio > 0.5) {
                        riskScore = 65; // 높은 이상치 비율
                    } else if (anomalyRatio > 0.3) {
                        riskScore = 50; // 중간 이상치 비율
                    } else {
                        riskScore = 35; // 낮은 이상치 비율
                    }
                }
            }

            // 최신 작업 상태 반영
            if (baselineStatus && baselineStatus.latest_job) {
                if (baselineStatus.latest_job.status === 'success') {
                    riskScore = Math.max(15, riskScore - 10); // 성공 시 위험 감소
                } else if (baselineStatus.latest_job.status === 'failed') {
                    riskScore = Math.min(90, riskScore + 20); // 실패 시 위험 증가
                } else if (baselineStatus.latest_job.status === 'running') {
                    riskScore = Math.max(25, riskScore - 5); // 진행 중일 때 약간 감소
                }
            }

            return Math.round(riskScore);
        }

        // 시간대별 패턴 데이터만 로드
        async function loadHourlyPatternsData(profileId) {
            try {
                console.log('시간대별 패턴 데이터 로딩 시작:', profileId);

                // 시간대별 패턴 데이터 로드
                const patternsResponse = await fetch(`/api/profiles/${profileId}/hourly-patterns`);
                if (patternsResponse.ok) {
                    const patternsData = await patternsResponse.json();
                    console.log('시간대별 패턴 데이터:', patternsData);
                    updateHourlyPatternsChart(patternsData);
                } else {
                    console.warn('시간대별 패턴 데이터 로드 실패:', patternsResponse.status);
                }

            } catch (error) {
                console.error('시간대별 패턴 데이터 로딩 실패:', error);
            }
        }

        // 실제 분석 결과로 차트 업데이트
        async function updateAnalysisCharts(baselineResults) {
            console.log('차트 업데이트 시작:', baselineResults);

            // 베이스라인 결과를 전역 변수에 저장하여 다른 함수에서 사용할 수 있도록 함
            window.currentBaselineResults = baselineResults;

            // 베이스라인 결과가 없는 경우
            if (!baselineResults || !baselineResults.baselines || baselineResults.baselines.length === 0) {
                // API 구현 상태에 따른 메시지 표시
                let message = '베이스라인 분석 결과가 없습니다';
                let detail = '베이스라인 생성 후 분석 결과가 표시됩니다';

                if (baselineResults && baselineResults.source === 'api_not_implemented') {
                    message = '베이스라인 엔진 API가 아직 구현되지 않았습니다';
                    detail = '다음 API 구현 후 실제 분석 결과를 확인할 수 있습니다';
                } else if (baselineResults && baselineResults.source === 'baseline_engine_error') {
                    message = '베이스라인 엔진에서 데이터를 조회할 수 없습니다';
                    detail = '베이스라인 엔진 서버 상태를 확인해주세요';
                }

                updatePlaceholderCharts(message, detail, baselineResults);
                return;
            }



            // 1. 시간대별 패턴 데이터 로드 및 차트 업데이트
            const profileId = getProfileIdFromUrl();
            await loadHourlyPatternsData(profileId);

            // 2. 3가지 분석 차트 업데이트
            updateTimeBasedChart(baselineResults);
            updateNetworkBasedChart(baselineResults);
            updateAccessBasedChart(baselineResults);

            // 3. 이상 탐지 결과 업데이트
            updateAnomalyDetectionResults(baselineResults);

            // 4. 시간별 활동 패턴 차트 업데이트 (기존 함수 유지)
            updateActivityTimelineChart(baselineResults);

            // 5. 권장사항 업데이트
            updateRecommendations(baselineResults);

            // 베이스라인 메트릭 화면 제거됨
        }

        // 플레이스홀더 차트 업데이트
        function updatePlaceholderCharts(message, detail, baselineResults) {
            const placeholders = document.querySelectorAll('.chart-placeholder');
            placeholders.forEach(placeholder => {
                let icon = '📊';
                let additionalInfo = '';

                if (baselineResults && baselineResults.source === 'api_not_implemented') {
                    icon = '⚙️';
                    additionalInfo = `
                        <div style="margin-top: 1rem; padding: 1rem; background: rgba(245, 158, 11, 0.1); border-radius: 0.5rem; border-left: 3px solid #f59e0b;">
                            <div style="color: #f59e0b; font-weight: 600; margin-bottom: 0.5rem;">필요한 API:</div>
                            <div style="font-size: 0.8rem; color: #94a3b8;">
                                ${baselineResults.required_apis ? baselineResults.required_apis.map(api => `• ${api}`).join('<br>') : ''}
                            </div>
                        </div>
                    `;
                } else if (baselineResults && baselineResults.source === 'baseline_engine_error') {
                    icon = '⚠️';
                    additionalInfo = `
                        <div style="margin-top: 1rem; padding: 1rem; background: rgba(239, 68, 68, 0.1); border-radius: 0.5rem; border-left: 3px solid #ef4444;">
                            <div style="color: #ef4444; font-weight: 600; margin-bottom: 0.5rem;">오류 발생</div>
                            <div style="font-size: 0.8rem; color: #94a3b8;">
                                베이스라인 엔진 연결을 확인하거나 관리자에게 문의하세요
                            </div>
                        </div>
                    `;
                }

                placeholder.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: #94a3b8; padding: 1rem;">
                        <div style="font-size: 2rem; margin-bottom: 1rem;">${icon}</div>
                        <div style="font-weight: 600; margin-bottom: 0.5rem;">${message}</div>
                        <div style="font-size: 0.8rem; text-align: center;">${detail}</div>
                        ${additionalInfo}
                    </div>
                `;
                placeholder.style.background = 'rgba(51, 65, 85, 0.3)';
                placeholder.style.minHeight = '200px';
                placeholder.style.display = 'flex';
                placeholder.style.alignItems = 'center';
                placeholder.style.justifyContent = 'center';
            });
        }

        // 시간 기반 분석 차트 업데이트
        function updateTimeBasedChart(baselineResults) {
            const chartContainer = document.getElementById('timeBasedChart');
            if (!chartContainer || !baselineResults) return;

            // Chart container 초기화
            chartContainer.innerHTML = '';
            chartContainer.style.position = 'relative';

            // Canvas 생성
            const canvas = document.createElement('canvas');
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            chartContainer.appendChild(canvas);

            const baselines = baselineResults.baselines || [];

            // 시간 기반 메트릭들
            const timeMetrics = [
                'login_time_pattern',
                'session_duration',
                'after_hours_activity',
                'weekend_holiday_access',
                'login_frequency_change'
            ];

            // 베이스라인에서 시간 관련 메트릭 추출
            const availableMetrics = baselines
                .filter(baseline => timeMetrics.includes(baseline.metric_name))
                .slice(0, 5);

            // 디버깅 정보 출력
            console.log('시간 기반 분석 - 사용 가능한 메트릭:', availableMetrics.map(m => m.metric_name));

            // 차트 제목 업데이트
            const timeBasedTitle = document.querySelector('#timeBasedChart').closest('div').querySelector('h4');
            if (timeBasedTitle) {
                timeBasedTitle.innerHTML = `
                    <span style="font-size: 1.5rem; margin-right: 0.5rem;">⏰</span>
                    시간 기반 분석
                    <span style="background: rgba(99, 102, 241, 0.3); color: #c7d2fe; padding: 0.2rem 0.5rem; border-radius: 0.25rem; font-size: 0.8rem; margin-left: 0.5rem;">
                        ${availableMetrics.length}개 메트릭
                    </span>
                `;
            }

            if (availableMetrics.length === 0) {
                chartContainer.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 250px; color: #94a3b8; text-align: center;">
                        <div>
                            <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">⏰</div>
                            <div style="font-size: 0.9rem;">시간 기반 분석 데이터 없음</div>
                        </div>
                    </div>
                `;
                return;
            }

            // 바 차트 데이터 준비 (실제 베이스라인 데이터 사용)
            const labels = availableMetrics.map(metric => getMetricDisplayName(metric.metric_name));
            const currentData = availableMetrics.map(metric => (metric.quality_score || 0) * 100);

            // 품질 점수에 따른 색상 결정
            const backgroundColors = currentData.map(score => {
                if (score >= 80) return 'rgba(34, 197, 94, 0.6)';      // 녹색
                if (score >= 60) return 'rgba(234, 179, 8, 0.6)';       // 노란색
                return 'rgba(239, 68, 68, 0.6)';                        // 빨간색
            });

            const borderColors = currentData.map(score => {
                if (score >= 80) return '#22c55e';     // 녹색
                if (score >= 60) return '#eab308';      // 노란색
                return '#ef4444';                       // 빨간색
            });

            // 실제 사용된 메트릭 목록 업데이트
            const timeBasedMetricsList = document.getElementById('timeBasedMetricsList');
            if (timeBasedMetricsList) {
                const metricNames = availableMetrics.map(m => getMetricDisplayName(m.metric_name)).join(', ');
                timeBasedMetricsList.innerHTML = `실제 분석된 메트릭: ${metricNames}`;
            }

            // Chart.js 바 차트 생성
            new Chart(canvas, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: '품질 점수',
                            data: currentData,
                            backgroundColor: backgroundColors,
                            borderColor: borderColors,
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                color: '#94a3b8'
                            },
                            grid: {
                                color: 'rgba(148, 163, 184, 0.1)'
                            }
                        },
                        x: {
                            ticks: {
                                color: '#94a3b8',
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });
        }

        // 네트워크 기반 분석 차트 업데이트
        function updateNetworkBasedChart(baselineResults) {
            const chartContainer = document.getElementById('networkBasedChart');
            if (!chartContainer || !baselineResults) return;

            // Chart container 초기화
            chartContainer.innerHTML = '';
            chartContainer.style.position = 'relative';

            // Canvas 생성
            const canvas = document.createElement('canvas');
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            chartContainer.appendChild(canvas);

            const baselines = baselineResults.baselines || [];

            // 네트워크 기반 메트릭들
            const networkMetrics = [
                'ip_address_pattern',
                'geo_location_analysis',
                'data_volume_transfer',
                'impossible_travel_detection',
                'vpn_usage_pattern'
            ];

            // 베이스라인에서 네트워크 관련 메트릭 추출
            const availableMetrics = baselines
                .filter(baseline => networkMetrics.includes(baseline.metric_name))
                .slice(0, 5);

            // 디버깅 정보 출력
            console.log('네트워크 기반 분석 - 사용 가능한 메트릭:', availableMetrics.map(m => m.metric_name));

            // 차트 제목 업데이트
            const networkBasedTitle = document.querySelector('#networkBasedChart').closest('div').querySelector('h4');
            if (networkBasedTitle) {
                networkBasedTitle.innerHTML = `
                    <span style="font-size: 1.5rem; margin-right: 0.5rem;">🌐</span>
                    네트워크 기반 분석
                    <span style="background: rgba(6, 182, 212, 0.3); color: #7dd3fc; padding: 0.2rem 0.5rem; border-radius: 0.25rem; font-size: 0.8rem; margin-left: 0.5rem;">
                        ${availableMetrics.length}개 메트릭
                    </span>
                `;
            }

            if (availableMetrics.length === 0) {
                chartContainer.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 250px; color: #94a3b8; text-align: center;">
                        <div>
                            <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">🌐</div>
                            <div style="font-size: 0.9rem;">네트워크 기반 분석 데이터 없음</div>
                        </div>
                    </div>
                `;
                return;
            }

            // 레이더 차트 데이터 준비 (실제 베이스라인 데이터 사용)
            const labels = availableMetrics.map(metric => getMetricDisplayName(metric.metric_name));
            const currentData = availableMetrics.map(metric => (metric.quality_score || 0) * 100);

            // 실제 사용된 메트릭 목록 업데이트
            const networkBasedMetricsList = document.getElementById('networkBasedMetricsList');
            if (networkBasedMetricsList) {
                const metricNames = availableMetrics.map(m => getMetricDisplayName(m.metric_name)).join(', ');
                networkBasedMetricsList.innerHTML = `실제 분석된 메트릭: ${metricNames}`;
            }

            // Chart.js 레이더 차트 생성
            new Chart(canvas, {
                type: 'radar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: '품질 점수',
                            data: currentData,
                            borderColor: '#06b6d4',
                            backgroundColor: 'rgba(6, 182, 212, 0.2)',
                            borderWidth: 2,
                            pointBackgroundColor: '#06b6d4',
                            pointBorderColor: '#ffffff',
                            pointBorderWidth: 2,
                            pointRadius: 3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                color: '#94a3b8',
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                color: 'rgba(148, 163, 184, 0.1)'
                            },
                            pointLabels: {
                                color: '#94a3b8',
                                font: {
                                    size: 10
                                }
                            }
                        }
                    }
                }
            });
        }

        // 접근 기반 분석 차트 업데이트
        function updateAccessBasedChart(baselineResults) {
            const chartContainer = document.getElementById('accessBasedChart');
            if (!chartContainer || !baselineResults) return;

            // Chart container 초기화
            chartContainer.innerHTML = '';
            chartContainer.style.position = 'relative';

            // Canvas 생성
            const canvas = document.createElement('canvas');
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            chartContainer.appendChild(canvas);

            const baselines = baselineResults.baselines || [];

            // 접근 기반 메트릭들
            const accessMetrics = [
                'concurrent_session_detection',
                'network_device_change',
                'bandwidth_usage_anomaly',
                'connection_pattern_analysis',
                'timezone_anomaly_access'
            ];

            // 베이스라인에서 접근 관련 메트릭 추출
            const availableMetrics = baselines
                .filter(baseline => accessMetrics.includes(baseline.metric_name))
                .slice(0, 5);

            // 디버깅 정보 출력
            console.log('접근 기반 분석 - 사용 가능한 메트릭:', availableMetrics.map(m => m.metric_name));

            // 차트 제목 업데이트
            const accessBasedTitle = document.querySelector('#accessBasedChart').closest('div').querySelector('h4');
            if (accessBasedTitle) {
                accessBasedTitle.innerHTML = `
                    <span style="font-size: 1.5rem; margin-right: 0.5rem;">🔐</span>
                    접근 기반 분석
                    <span style="background: rgba(168, 85, 247, 0.3); color: #d8b4fe; padding: 0.2rem 0.5rem; border-radius: 0.25rem; font-size: 0.8rem; margin-left: 0.5rem;">
                        ${availableMetrics.length}개 메트릭
                    </span>
                `;
            }

            if (availableMetrics.length === 0) {
                chartContainer.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 250px; color: #94a3b8; text-align: center;">
                        <div>
                            <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">🔐</div>
                            <div style="font-size: 0.9rem;">접근 기반 분석 데이터 없음</div>
                        </div>
                    </div>
                `;
                return;
            }

            // 도넛 차트 데이터 준비 (실제 베이스라인 데이터 사용)
            const labels = availableMetrics.map(metric => getMetricDisplayName(metric.metric_name));
            const currentData = availableMetrics.map(metric => (metric.quality_score || 0) * 100);

            // 품질 점수에 따른 색상 결정
            const backgroundColors = currentData.map(score => {
                if (score >= 80) return 'rgba(34, 197, 94, 0.6)';      // 녹색
                if (score >= 60) return 'rgba(234, 179, 8, 0.6)';       // 노란색
                return 'rgba(239, 68, 68, 0.6)';                        // 빨간색
            });

            const borderColors = currentData.map(score => {
                if (score >= 80) return '#22c55e';     // 녹색
                if (score >= 60) return '#eab308';      // 노란색
                return '#ef4444';                       // 빨간색
            });

            // 실제 사용된 메트릭 목록 업데이트
            const accessBasedMetricsList = document.getElementById('accessBasedMetricsList');
            if (accessBasedMetricsList) {
                const metricNames = availableMetrics.map(m => getMetricDisplayName(m.metric_name)).join(', ');
                accessBasedMetricsList.innerHTML = `실제 분석된 메트릭: ${metricNames}`;
            }

            // Chart.js 도넛 차트 생성
            new Chart(canvas, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            data: currentData,
                            backgroundColor: backgroundColors,
                            borderColor: borderColors,
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: '#94a3b8',
                                font: {
                                    size: 10
                                },
                                padding: 10,
                                usePointStyle: true,
                                pointStyle: 'circle'
                            }
                        }
                    }
                }
            });
        }

        // 이상 탐지 결과 업데이트
        function updateAnomalyDetectionResults(baselineResults) {
            const anomaliesSection = document.querySelector('.data-table tbody');
            if (!anomaliesSection) return;

            const anomalies = baselineResults.anomalies;

            if (!anomalies || (Array.isArray(anomalies) && anomalies.length === 0) ||
                (anomalies.anomalies && anomalies.anomalies.length === 0)) {
                anomaliesSection.innerHTML = `
                    <tr>
                        <td colspan="4" style="text-align: center; color: #10b981; padding: 2rem;">
                            ✅ 현재 이상 행동이 탐지되지 않았습니다
                        </td>
                    </tr>
                `;
                return;
            }

            const anomalyList = Array.isArray(anomalies) ? anomalies : (anomalies.anomalies || []);

            anomaliesSection.innerHTML = anomalyList.slice(0, 10).map((anomaly, index) => {
                const score = anomaly.deviation_score || anomaly.score || 0;
                const severity = score > 0.8 ? 'high' : score > 0.6 ? 'medium' : 'low';
                const severityText = severity === 'high' ? '높음' : severity === 'medium' ? '중간' : '낮음';

                return `
                    <tr>
                        <td>${anomaly.target_entity || `Entity-${index + 1}`}</td>
                        <td>${anomaly.metric_name || '패턴 이상'}</td>
                        <td class="severity-${severity}">
                            <span class="severity-indicator"></span>
                            ${severityText}
                        </td>
                        <td>${anomaly.detection_time || new Date().toLocaleDateString('ko-KR')}</td>
                    </tr>
                `;
            }).join('');
        }

        // 시계열 데이터 로드 (새로운 베이스라인 엔진 API 사용)
        async function loadTimelineData(profileId) {
            try {
                console.log('시계열 데이터 로딩 시작:', profileId);



                // 2. 시간대별 패턴 데이터 로드
                const patternsResponse = await fetch(`/api/profiles/${profileId}/hourly-patterns`);
                let patternsData = null;
                if (patternsResponse.ok) {
                    patternsData = await patternsResponse.json();
                    console.log('시간대별 패턴 데이터:', patternsData);
                    updateHourlyPatternsChart(patternsData);
                } else {
                    console.warn('시간대별 패턴 데이터 로드 실패:', patternsResponse.status);
                }

                // 3. 이상치 시계열 데이터 로드
                const anomalyTimelineResponse = await fetch(`/api/profiles/${profileId}/anomalies/timeline?days=30`);
                let anomalyTimelineData = null;
                if (anomalyTimelineResponse.ok) {
                    anomalyTimelineData = await anomalyTimelineResponse.json();
                    console.log('이상치 시계열 데이터:', anomalyTimelineData);
                } else {
                    console.warn('이상치 시계열 데이터 로드 실패:', anomalyTimelineResponse.status);
                }

                // 4. 품질 추이 데이터 로드
                const qualityTrendsResponse = await fetch(`/api/profiles/${profileId}/quality-trends`);
                let qualityTrendsData = null;
                if (qualityTrendsResponse.ok) {
                    qualityTrendsData = await qualityTrendsResponse.json();
                    console.log('품질 추이 데이터:', qualityTrendsData);
                } else {
                    console.warn('품질 추이 데이터 로드 실패:', qualityTrendsResponse.status);
                }

                return {
                    timeline: timelineData,
                    patterns: patternsData,
                    anomalyTimeline: anomalyTimelineData,
                    qualityTrends: qualityTrendsData
                };

            } catch (error) {
                console.error('시계열 데이터 로딩 실패:', error);
                return null;
            }
        }



        // 시간대별 패턴 차트 업데이트
        function updateHourlyPatternsChart(patternsData) {
            console.log('시간대별 패턴 데이터 수신:', patternsData);

            const heatmapContainer = document.querySelector('.heatmap-container');
            if (!heatmapContainer || !patternsData) {
                return;
            }

            // 히트맵 컨테이너를 차트 컨테이너로 설정
            heatmapContainer.innerHTML = '';
            heatmapContainer.style.height = '300px';
            heatmapContainer.style.position = 'relative';

            // Canvas 생성
            const canvas = document.createElement('canvas');
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            heatmapContainer.appendChild(canvas);

            // 시간대별 데이터 준비 (24시간)
            const hours = Array.from({length: 24}, (_, i) => i.toString().padStart(2, '0') + ':00');

                        // 주요 메트릭들의 시간대별 활동량 데이터 추출 (데이터가 있는 메트릭만)
            const datasets = [];
            const metricColors = {
                'login_time_pattern': '#6366f1',
                'session_duration': '#10b981',
                'vpn_usage_pattern': '#f59e0b',
                'geo_location_analysis': '#ef4444',
                'data_volume_transfer': '#8b5cf6',
                'network_device_change': '#06b6d4',
                'after_hours_activity': '#f97316',
                'concurrent_session_detection': '#84cc16'
            };

            // 실제 데이터가 있는 메트릭만 필터링
            Object.keys(patternsData.hourly_patterns || {}).forEach((metricName, index) => {
                const metricData = patternsData.hourly_patterns[metricName];
                if (metricData) {
                    const hourlyData = hours.map(hour => {
                        const hourNum = parseInt(hour.split(':')[0]);
                        return metricData[hourNum] ? metricData[hourNum].avg : 0;
                    });

                    // 실제 데이터가 있는지 확인 (모든 값이 0이 아닌지)
                    const hasData = hourlyData.some(value => value > 0);

                    if (hasData) {
                        datasets.push({
                            label: getMetricDisplayName(metricName),
                            data: hourlyData,
                            backgroundColor: metricColors[metricName] || getRandomColor(index),
                            borderColor: metricColors[metricName] || getRandomColor(index),
                            borderWidth: 1,
                            alpha: 0.7
                        });
                    }
                }
            });

            // Chart.js로 바 차트 생성 (히트맵 대신 시간대별 바 차트)
            new Chart(canvas, {
                type: 'bar',
                data: {
                    labels: hours,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: '시간대별 활동 패턴',
                            color: '#e2e8f0',
                            font: {
                                size: 14,
                                weight: 'bold'
                            }
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                color: '#e2e8f0',
                                usePointStyle: true,
                                pointStyle: 'rect'
                            }
                        },
                        tooltip: {
                            callbacks: {
                                title: function(tooltipItems) {
                                    return `${tooltipItems[0].label} 시간대`;
                                },
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: '#94a3b8'
                            },
                            grid: {
                                color: 'rgba(51, 65, 85, 0.3)'
                            },
                            title: {
                                display: true,
                                text: '활동량',
                                color: '#94a3b8'
                            }
                        },
                        x: {
                            ticks: {
                                color: '#94a3b8',
                                maxRotation: 45,
                                minRotation: 45
                            },
                            grid: {
                                color: 'rgba(51, 65, 85, 0.3)'
                            },
                            title: {
                                display: true,
                                text: '시간대',
                                color: '#94a3b8'
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });

            // 패턴 분석 요약 정보 추가
            if (patternsData.patterns) {
                const patterns = patternsData.patterns;
                const summaryHtml = `
                    <div style="position: absolute; top: 10px; right: 10px; background: rgba(30, 41, 59, 0.9); padding: 0.75rem; border-radius: 0.5rem; font-size: 0.8rem; max-width: 200px;">
                        <div style="color: #a5b4fc; margin-bottom: 0.5rem; font-weight: 600;">📊 패턴 분석</div>
                        <div style="color: #e2e8f0; margin-bottom: 0.25rem;">피크 시간: ${patterns.peak_hours?.slice(0, 3).join(', ') || '-'}시</div>
                        <div style="color: #10b981; margin-bottom: 0.25rem;">업무시간 활동: ${patterns.business_hours_activity ? (patterns.business_hours_activity * 100).toFixed(1) : '-'}%</div>
                        <div style="color: #f59e0b;">시간외 활동: ${patterns.after_hours_activity ? (patterns.after_hours_activity * 100).toFixed(1) : '-'}%</div>
                    </div>
                `;
                heatmapContainer.insertAdjacentHTML('beforeend', summaryHtml);
            }

            // 데이터가 없는 경우 메시지 표시
            if (datasets.length === 0) {
                heatmapContainer.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 300px; color: #94a3b8; text-align: center;">
                        <div>
                            <div style="font-size: 2rem; margin-bottom: 1rem;">📊</div>
                            <div>시간대별 패턴 데이터가 부족합니다</div>
                            <div style="font-size: 0.8rem; margin-top: 0.5rem;">더 많은 데이터가 수집되면 패턴이 표시됩니다</div>
                        </div>
                    </div>
                `;
                return;
            }
        }



        // 차트 캔버스 생성
        function createChartCanvas(container) {
            // 기존 내용 제거
            container.innerHTML = '';

            const canvas = document.createElement('canvas');
            canvas.style.width = '100%';
            canvas.style.height = '400px';
            container.appendChild(canvas);
            return canvas;
        }

        // 메트릭 표시 이름 가져오기
        function getMetricDisplayName(metricName) {
            const displayNames = {
                'login_time_pattern': '로그인 시간 패턴',
                'session_duration': '세션 지속시간',
                'vpn_usage_pattern': 'VPN 사용 패턴',
                'geo_location_analysis': '지리적 위치 분석',
                'data_volume_transfer': '데이터 전송량',
                'network_device_change': '네트워크 기기 변경',
                'ip_address_pattern': 'IP 주소 패턴',
                'impossible_travel_detection': '불가능한 이동 탐지',
                'after_hours_activity': '업무시간 외 활동',
                'weekend_holiday_access': '주말/휴일 접속'
            };
            return displayNames[metricName] || metricName;
        }

        // 랜덤 색상 생성
        function getRandomColor(index) {
            const colors = [
                '#6366f1', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#06b6d4',
                '#84cc16', '#f97316', '#ec4899', '#14b8a6', '#f472b6', '#a78bfa'
            ];
            return colors[index % colors.length];
        }

        // 활동 타임라인 차트 업데이트 (기존 함수 - 최근 활동 로그용으로 유지)
        function updateActivityTimelineChart(baselineResults) {
            const timelineContainer = document.querySelector('.activity-timeline');
            if (!timelineContainer) return;

            // 베이스라인 생성 이력을 시계열 형태로 표시
            const baselines = baselineResults.baselines;
            const summary = baselineResults.summary;

            timelineContainer.innerHTML = baselines.slice(0, 5).map((baseline, index) => `
                <div class="timeline-item">
                    <div class="timeline-time">${new Date(baseline.created_at || new Date()).toLocaleDateString('ko-KR')}</div>
                    <div class="timeline-content">
                        <strong>${baseline.metric_name || '메트릭'}</strong> 베이스라인 생성
                        <div style="color: #94a3b8; font-size: 0.8rem; margin-top: 0.25rem;">
                            품질 점수: ${((baseline.quality_score || 0) * 100).toFixed(1)}% •
                            버전: ${baseline.version || '1.0'} •
                            상태: ${baseline.status || 'active'}
                        </div>
                    </div>
                </div>
            `).join('') + `
                <div class="timeline-item">
                    <div class="timeline-time">${new Date().toLocaleDateString('ko-KR')}</div>
                    <div class="timeline-content">
                        <strong>분석 요약</strong>
                        <div style="color: #94a3b8; font-size: 0.8rem; margin-top: 0.25rem;">
                            총 ${summary?.total_baselines || baselines.length}개 베이스라인 •
                            이상치 ${summary?.anomaly_count || 0}개 탐지 •
                            평균 품질: ${(baselines.reduce((acc, b) => acc + (b.quality_score || 0), 0) / baselines.length * 100).toFixed(1)}%
                        </div>
                    </div>
                </div>
            `;
        }

        // 권장사항 업데이트
        function updateRecommendations(baselineResults) {
            const recommendationsContainer = document.querySelector('.recommendations');
            if (!recommendationsContainer) return;

            const summary = baselineResults.summary || {};
            const hasAnomalies = (summary.anomaly_count || 0) > 0;

            recommendationsContainer.innerHTML = `
                <div class="recommendation-item">
                    <div class="recommendation-icon">📊</div>
                    <div class="recommendation-content">
                        <div class="recommendation-title">베이스라인 분석 완료</div>
                        <div class="recommendation-text">
                            총 ${summary.total_baselines || baselineResults.baselines?.length || 0}개의 메트릭에 대해 베이스라인 분석이 완료되었습니다.
                            지속적인 모니터링을 통해 사용자 행동 패턴의 변화를 추적하세요.
                        </div>
                    </div>
                </div>

                ${hasAnomalies ? `
                    <div class="recommendation-item">
                        <div class="recommendation-icon">⚠️</div>
                        <div class="recommendation-content">
                            <div class="recommendation-title">이상 행동 탐지됨</div>
                            <div class="recommendation-text">
                                ${summary.anomaly_count || 0}개의 이상 행동이 탐지되었습니다.
                                각 항목을 검토하여 실제 보안 위협인지 확인하고 필요시 추가 조치를 취하세요.
                            </div>
                        </div>
                    </div>
                ` : `
                    <div class="recommendation-item">
                        <div class="recommendation-icon">✅</div>
                        <div class="recommendation-content">
                            <div class="recommendation-title">정상 행동 패턴</div>
                            <div class="recommendation-text">
                                현재 이상 행동이 탐지되지 않았습니다.
                                베이스라인이 정상적으로 작동하고 있으며, 정기적인 검토를 계속하세요.
                            </div>
                        </div>
                    </div>
                `}

                <div class="recommendation-item">
                    <div class="recommendation-icon">🔄</div>
                    <div class="recommendation-content">
                        <div class="recommendation-title">정기적 베이스라인 업데이트</div>
                        <div class="recommendation-text">
                            사용자 행동 패턴은 시간에 따라 변화할 수 있습니다.
                            월 1회 이상 베이스라인을 재생성하여 최신 패턴을 반영하세요.
                        </div>
                    </div>
                </div>
            `;
        }
    </script>
</body>
</html>
